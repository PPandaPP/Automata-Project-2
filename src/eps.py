from nltk import CFG, Production, Nonterminal
from nltk import Tree
from itertools import permutations

## need restriction to only 
gg = '''HTML ->  L0 H L1 B L2 
L0 -> '<html><head>'
L1 -> '</head><body>'
L2 -> '</body></html>'
H ->  L3 T L4 
L3 -> '<title>'
L4 -> '</title>'
C -> T
B -> C B
B -> D
B -> C
D -> 'None'
C -> L8 T L9 
T -> 'a'
T -> L10
L10 -> 'None'
'''

gg2 = '''
HTML ->  L0 H L1 B L2 
L0 -> '<html><head>'
L1 -> '</head><body>'
L2 -> '</body></html>'
H ->  L3 T L4 
L3 -> '<title>'
L4 -> '</title>'
C -> T
B -> C
B -> C B
C ->  L5 
L5 -> '<img>'
C ->  L6 T L7 
L6 -> '<br>'
L7 -> '</br>'
C ->  L8 T L9 
L8 -> '<hr>'
L9 -> '</hr>'
T -> L10
L10 -> 'None'
T ->  L11 
L11 -> 'z'
'''

gg3 = '''
S -> A D B G
A -> B C
B -> C
A -> G
C -> 'None'
G -> 'a'
D -> 'b'
T -> B
'''

def check_nullable(grammar, child, nullable, depth):
    for p in grammar.productions(): ## aqui se esta cortando
        # check for production rules generated by child variable
        if str(child) == str(p.lhs()):
            # base case 
            if('None' in p.rhs() and len(p.rhs()) == 1):
                nullable.add(p.lhs())
                return(True)
            
            # recursive step
            else:
                count_nullable_children = 0
                for child2 in p.rhs():
                    if(child2 != p.lhs()):
                       
                        found_none = check_nullable(grammar, child2, nullable, depth+1)
                        #print(depth, p.lhs(), p.rhs(), "checking: ", child2, found_none)
                        # backtracking
                        if(found_none):
                            count_nullable_children += 1 
                # if all variables can derive epsilon, is nullable #            
                if(count_nullable_children == len(p.rhs())):
                    nullable.add(p.lhs())
                    return(True) 
    return(False)

##### Helper function to remove all possible combinations of nullable ####
def removing_combis(og, nullable):
    # perms will hold all possible combinations of nullable #
    perms = []
    for i in range(1, len(nullable)+1):
        # seq is a list of combinations of size i of nullable #
        seq = list(permutations(nullable, i))
        for element in seq:
            perms.append(list(element))
    # finals will hold the combinations of removing each element in seq #
    finals = []
    for remove_list in perms:
        res = [i for i in list(og) if i not in remove_list]
        if tuple(res) not in finals:
            finals.append(tuple(res))
            
    return(finals)


def remove_all_epsilons(grammar):
    nullable = set()  
    if(check_nullable(grammar, grammar.start(), nullable, 0)):
        nullable.add(grammar.start())
            
    # tienen valor cero #
    print("Nullable: ", nullable, "\n")
    
    print("before processing:", grammar.productions())  
    new_prods = grammar.productions().copy()
    # add new rules without each of the nullables
    for p in grammar.productions():
        for rr in p.rhs():
            if rr in nullable:
                lhs = p.lhs()
                # rules list has all the combinations when removing each of the variables in nullable #
                rules_list = removing_combis(p.rhs(), nullable)
                
                if(len(rules_list) == 0 or len(rules_list[0]) == 0):
                    continue
                # add each combination #
                for element in rules_list:
                    if(len(element) > 0):
                        # create rule of type Production() #
                        new_production = Production(lhs, element)
                        if(new_production not in new_prods):
                            new_prods.append(new_production)
    print(new_prods)   
    
    # Process to remove rules #
    # Step 1: identify all rules that generate 'None'
    to_rem = set()
    for element in new_prods:
        r = [i for i in element.rhs() if i not in nullable]
        # if all elements in right-hand-side are in nullable or if leads to 'None' directly #
        if(len(r) == 0 or (len(element.rhs()) == 1 and element.rhs()[0] == 'None')):
            to_rem.add(element.lhs())
    print(to_rem)
    
    # Step 1.5: create list of Productions to delete (cant iterate and remove concurrently) #
    to_rem2 = []
    for element in new_prods:
        for rights in element.rhs():
            if rights in to_rem or rights == 'None':
                print(element)
                if(element in new_prods):
                    to_rem2.append(element)
    print(to_rem2)
    
    # Step 2: remove Productions in list #
    for element in to_rem2:
        if element in new_prods:
            new_prods.remove(element)
        
    # Step 3: create new grammar with these rules # 
    new_grammar = CFG(grammar.start(), new_prods)
    return(new_grammar)

grammar = CFG.fromstring(gg3)  
print("\n", "Before eliminating epsilons: ")
for p in grammar.productions():          
        print(p)  
         
new_grammar = remove_all_epsilons(grammar)

print("\n", "After eliminating epsilons: ")
for p in new_grammar.productions():          
        print(p)